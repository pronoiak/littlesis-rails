#!/usr/bin/env ruby

require 'getoptlong'
require 'fileutils'

REPO = File.expand_path('..', __dir__).freeze

$database = {
  name: ENV.fetch('LITTLESIS_DATABASE_NAME', 'littlesis'),
  user: ENV.fetch('LITTLESIS_DATABASE_USER', 'littlesis'),
  password: ENV.fetch('LITTLESIS_DATABASE_PASSWORD', 'themanbehindthemanbehindthethrone'),
  host: ENV.fetch('LITTLESIS_DATABASE_HOST', 'postgres')
}

$rails_env = ENV.fetch('RAILS_ENV', 'development')
$deploy_branch = 'main'

def help
  puts <<TEXT
Usage: littlesis [-tdP] <command> [--] [arguments for command]

Commands
           docker           run any docker-compose comand
           up               start docker containers
           down             stop docker containers
           delete           deletes database by removing docker volumes
           build            build littlesis docker image
           bash             interative bash shell
           logs             follow rails logs
           status           check status of applications
           console          launch rails console
           redis            launch redi cli
           data             external data ETL tools
           fec              FEC data ETL tools
           deploy           deploys to latest commit on main
           edit             select file to open with $EDITDOR
           runner           run bin/rails runner <file>
           script           execute named script in lib/scripts/
           esbuild          bundle javascript

Aliases
           bundle
           gem
           pumactl
           rspec
           rails
           psql
           pg_dump
           pg_restore
           node
           npm
           git
           rg
           find

TEXT
end

def set_env_to_test
  $rails_env = 'test'
  $database[:name] = 'littlesis_test'
  ENV['RAILS_ENV'] = $rails_env
end

def production_environment?
  $rails_env == 'production'
end

def database_connection
  "postgresql://#{$database[:user]}:#{$database[:password]}@#{$database[:host]}/#{$database[:name]}"
end

def setup_folders
  %w[tmp data data/external_data data/external_data/original data/external_data/csv public/oligrapher public/images
     public/images/large public/images/original public/images/profile public/images/small public/images/oligrapher].each do |folder|
    FileUtils.mkdir_p File.join(REPO, folder)
  end
end

def docker_compose(*args)
  Dir.chdir(REPO) do
    exec "docker-compose #{args.join(' ')}"
  end
end

def app_exec(cmd, bin: false, run: false, container: 'app')
  bin_path = $rails_env == 'production' ? '/var/www/littlesis/bin' : '/littlesis/bin'
  cmd = "#{bin_path}/#{cmd}" if bin

  if $rails_env == 'production'
    Dir.chdir(REPO) do
      if run
        exec cmd
      else
        puts `#{cmd}`
      end
    end
  else
    if run
      docker_compose 'run', '--rm', "-e RAILS_ENV=#{$rails_env}", container, cmd
    else
      docker_compose 'exec', ($stdout.tty? ? '' : '-T'), "-e RAILS_ENV=#{$rails_env}", container, cmd
    end
  end
end

def app_exec_bin(cmd)
  app_exec(cmd, bin: true)
end

def git(cmd)
  Dir.chdir(REPO) { `git #{cmd}` }
end

def systemd_service_check(service)
  status = system("systemctl is-active -q #{service}") ? '✓' : 'X'
  puts "[#{status}] #{service}"
end

def status
  current_commit = git("rev-parse --short HEAD").chomp
  current_branch = git("rev-parse --abbrev-ref HEAD").chomp

  puts "commit #{current_commit} on branch #{current_branch}"
  puts "Rails Environment \033[1m#{$rails_env}\033[0m"

  if production_environment?
    systemd_service_check 'littlesis'
    systemd_service_check 'littlesis-goodjob'
    systemd_service_check 'redis'
    systemd_service_check 'nginx'
    app_exec_bin 'rake ts:status'
  else
    running_services = Dir.chdir(REPO) { `docker-compose ps --services --filter status=running` }.split("\n")

    %w[redis postgres app nginx].each do |service|
      puts "[#{running_services.include?(service) ? '✓' : 'X'}] #{service} "
    end
    app_exec_bin 'rake ts:status'
  end
end

def yes_or_no?(msg)
  printf "#{msg}\n\e[31mpress 'y' to continue: \e[0m"
  $stdin.gets.strip.casecmp('y').zero?
end

def deploy
  raise "Cannot deploy unless mode = production" unless production_environment?

  Dir.chdir(REPO)

  modified_files = git("ls-files -m").split("\n")

  if modified_files.count.positive?
    puts "The following files have been modified:\n#{modified_files.join("\n")}\n"
    exit 1 unless yes_or_no?("Are you sure you want to deploy?")
  end

  puts "deploying branch #{$deploy_branch}"
  git("fetch origin #{$deploy_branch}")

  remote_commit = git("rev-parse \"origin/#{$deploy_branch}\"").chomp
  local_commit = git("rev-parse @").chomp

  if remote_commit == local_commit
    puts "No upstream changes"
    exit
  end

  git_subject = git("log --format=%s -n 1 \"#{remote_commit}\"")
  puts "Deploying #{remote_commit}: #{git_subject}"
  git("checkout $deploy_branch")
  git("pull")

  changed_files = git("diff --name-only #{remote_commit} #{local_commit}").split("\n")

  if changed_files.include?('Gemfile') || changed_files.include?('Gemfile.lock')
    app_exec_bin 'bundle install'
  end

  if changed_files.any? { |f| f.include?('db/migrate') }
    puts "These changes likely require a database update."
    if yes_or_no?("Would you like to run rake db:migrate now?")
      app_exec_bin 'rake db:migrate'
    end
  end

  if changed_files.include?('package-lock.json')
    app_exec 'npm ci'
  end

  if changed_files.include?('package-lock.json') || changed_files.any? { |f| f.include?('javascript') }
    esbuild
  end

  # TODO detech changes to Rails.application.config.littlesis.oligrapher_commit and run OligrapherAssetsService.run
  if changed_files.any? { |f| f.include?('package-lock.json') || f.include?('assets') || f.include?('javascript') }
    app_exec_bin 'rake assets:precompile'
  end

  puts "Restarting LittleSis"
  app_exec_bin 'pumactl -p tmp/puma.pid restart'
end

def logs
  prefix = if production_environment?
             "/var/www/littlesis"
           else
             "/littlesis"
           end

  logfile = "#{prefix}/log/#{$rails_env}.log"

  app_exec "/usr/bin/tail -f #{logfile}", run: true
end

def esbuild
  if production_environment?
    app_exec "npm run build"
  else
    container_name = "littlesis-esbuild"

    if `docker ps -q --filter name=#{container_name}`.empty?
      docker_compose 'run', '-d', '--rm', "--name #{container_name}", "-e RAILS_ENV=#{$rails_env}", 'app', 'npm run build-watch'
    else
      "#{container_name} is running. Execute \"docker rm -f littlesis-esbuild\" to remove it."
    end
  end
end

# Start processing options

opts = GetoptLong.new(
  ['--help', '-h', GetoptLong::NO_ARGUMENT],
  ['--test', '-t', GetoptLong::NO_ARGUMENT],
  ['--development', '-d', GetoptLong::NO_ARGUMENT],
  ['--production', '-P', GetoptLong::NO_ARGUMENT],
  ['--branch', GetoptLong::REQUIRED_ARGUMENT]
)

opts.each do |name, val|
  case name
  when '--help'
    help
    exit
  when '--test'
    set_env_to_test
  when '--development'
    $rails_env = 'development'
  when '--production'
    $rails_env = 'production'
  when '--branch'
    $deploy_branch = val
  end
end

ENV['RAILS_ENV'] = $rails_env

if ARGV.empty?
  help
  exit
end

rest = ARGV[1..].join(' ')

case ARGV.first
when 'help'
  help
when 'setup-folders'
  setup_folders
when 'docker', 'docker_compose', 'docker-compose'
  docker_compose rest
when 'up'
  docker_compose 'up -d'
when 'down'
  docker_compose 'down'
when 'delete'
  exit 1 if production_environment?

  if yes_or_no?("This is will delete the postgres database.")
    docker_compose 'down -v'
  end
when 'build'
  Dir.chdir(REPO) { exec "docker build -t littlesis:latest ." }
when 'pumactl'
  app_exec_bin "pumactl -p tmp/puma.pid #{rest}"
when 'test', 'rspec'
  set_env_to_test
  app_exec_bin "rspec #{rest}"
when 'rails'
  app_exec_bin "rails #{rest}"
when 'bundle'
  app_exec_bin "bundle #{rest}"
when 'gem'
  gem_path = production_environment? ? '/home/littlesis/.rbenv/shims/gem' : '/usr/local/bin/gem'
  app_exec "#{gem_path} #{rest}", run: true
when 'npm'
  app_exec "npm #{rest}"
when 'rake'
  app_exec_bin "rake #{rest}"
when 'runner'
  app_exec_bin "rails runner #{rest}"
when 'script'
  app_exec "bundle exec lib/scripts/#{rest}", bin: true, run: true
when 'bash'
  app_exec "/bin/bash --login #{rest}"
when 'console', 'c'
  app_exec "rails c #{rest}", bin: true, run: true
when 'redis'
  redis_host = production_environment? ? '127.0.0.1' : 'redis'
  app_exec "/usr/bin/redis-cli -h #{redis_host} #{rest}", run: true
when 'data'
  app_exec_bin "rails runner lib/scripts/data.rb #{rest}"
when 'fec'
  app_exec_bin "rails runner lib/scripts/fec.rb #{rest}"
when 'git'
  puts git(rest)
when 'rg', 'search'
  Dir.chdir(REPO) { exec "rg #{rest}" }
when 'find'
  Dir.chdir(REPO) { exec "find #{rest}" }
when 'edit'
  Dir.chdir(REPO) do
    selected = if rest == ''
                 `fd | fzf`.chomp
               else
                 rest
               end
    exec "$EDITOR #{selected}"
  end
when 'node'
  app_exec "/usr/bin/node #{rest}", run: true
when 'psql', 'pg_dump', 'pg_restore'
  app_exec "#{ARGV.first} #{database_connection} #{rest}", run: true, container: 'postgres'
when 'status'
  status
when 'deploy'
  deploy
when 'logs'
  logs
when 'esbuild'
  esbuild
else
  puts "Invalid Command: #{ARGV.first}"
  exit 1
end
