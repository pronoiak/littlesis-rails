#!/usr/bin/env ruby

require 'getoptlong'
require 'fileutils'

# Travel to Rails root relative to this file
REPO = File.expand_path('..', __dir__).freeze
Dir.chdir(REPO)

$database = {
  name: ENV.fetch('LITTLESIS_DATABASE_NAME', 'littlesis'),
  user: ENV.fetch('LITTLESIS_DATABASE_USER', 'littlesis'),
  password: ENV.fetch('LITTLESIS_DATABASE_PASSWORD', 'themanbehindthemanbehindthethrone'),
  host: ENV.fetch('LITTLESIS_DATABASE_HOST', 'postgres')
}

$rails_env = ENV.fetch('RAILS_ENV', 'development')
$deploy_branch = 'main'

$littlesis_systemd_services = %w[nginx.service redis-server.service redis-server.service littlesis.socket littlesis.service littlesis-goodjob.service littlesis-manticore.service littlesis-backup.service].freeze
$littlesis_docker_services = %w[app postgres redis nginx esbuild manticore title_extractor].freeze

def help
  puts <<TEXT
Usage: littlesis [-tdP] <command> [--] [arguments for command]

Commands
           docker           run any docker-compose comand
           up               start docker containers
           down             stop docker containers
           delete           deletes database by removing docker volumes
           build            build littlesis docker image
           bash             interative bash shell
           logs             follow rails logs
           status           check status of applications
           console          launch rails console
           redis            launch redi cli
           data             external data ETL tools
           fec              FEC data ETL tools
           deploy           deploys to latest commit on main
           edit             select file to open with $EDITDOR
           runner           run bin/rails runner <file>
           script           execute named script in lib/scripts/
           esbuild          bundle javascript
           pgenv            use: fish> eval (pgenv)

Aliases
           bundle
           gem
           pumactl
           rspec
           rails
           psql
           pg_dump
           pg_restore
           node
           npm
           git
           rg
           find

TEXT
end

def set_env_to_test
  $rails_env = 'test'
  $database[:name] = 'littlesis_test'
  ENV['RAILS_ENV'] = $rails_env
end

def production_environment?
  $rails_env == 'production'
end

def database_connection
  "postgresql://#{$database[:user]}:#{$database[:password]}@#{$database[:host]}/#{$database[:name]}"
end

def setup_folders
  %w[tmp data data/external_data data/external_data/original data/external_data/csv public/oligrapher public/images
     public/images/large public/images/original public/images/profile public/images/small public/images/oligrapher].each do |folder|
    FileUtils.mkdir_p File.join(REPO, folder)
  end
end

def app_exec(cmd, bin: false, use_exec: false, container: 'app', compose_command: 'run --rm')
  bin_path = $rails_env == 'production' ? '/var/www/littlesis/bin' : '/littlesis/bin'
  cmd = "#{bin_path}/#{cmd}" if bin

  if $rails_env == 'production'
    if use_exec
      exec cmd
    else
      `#{cmd}`
    end
  else
    docker_compose = "docker-compose #{compose_command} -e RAILS_ENV=#{$rails_env} #{container} #{cmd}"

    if use_exec
      exec docker_compose
    else
      `#{docker_compose}`
    end
  end
end

def app_exec_bin(cmd, **kwargs)
  app_exec(cmd, bin: true, **kwargs)
end

def app_exec_bin!(cmd, **kwargs)
  app_exec(cmd, bin: true, use_exec: true, **kwargs)
end

def git(cmd)
  Dir.chdir(REPO) { `git #{cmd}` }
end

def systemd_service_check(service)
  status = system("systemctl is-active -q #{service}") ? '✓' : 'X'
  puts "[#{status}] #{service}"
end

def status
  puts "Host\t#{File.read('/etc/hostname').chomp}"
  puts "Path\t#{REPO}"
  puts "Env\t#{$rails_env}"
  printf git('log --format="%h %cs %s" -n 1')

  if production_environment?
    $littlesis_systemd_services.each { |s| systemd_service_check(s) }
  else
    running_services = `docker-compose ps --services --filter status=running`.split("\n")

    $littlesis_docker_services.each do |service|
      puts "[#{running_services.include?(service) ? '✓' : 'X'}] #{service} "
    end
  end
end

def yes_or_no?(msg)
  printf "#{msg}\n\e[31mpress 'y' to continue: \e[0m"
  $stdin.gets.strip.casecmp('y').zero?
end

def logs
  prefix = if production_environment?
             "/var/www/littlesis"
           else
             "/littlesis"
           end

  logfile = "#{prefix}/log/#{$rails_env}.log"

  app_exec "/usr/bin/tail -f #{logfile}", use_exec: true
end

def pgenv
  puts <<~TEXT
    set -x PGHOST  #{$database[:host]};
    set -x PGUSER #{$database[:user]};
    set -x PGPASSWORD #{$database[:password]};
    set -x PGDATABASE #{$database[:name]};
  TEXT
end

# Start processing options

opts = GetoptLong.new(
  ['--help', '-h', GetoptLong::NO_ARGUMENT],
  ['--test', '-t', GetoptLong::NO_ARGUMENT],
  ['--development', '-d', GetoptLong::NO_ARGUMENT],
  ['--production', '-P', GetoptLong::NO_ARGUMENT],
  ['--branch', GetoptLong::REQUIRED_ARGUMENT]
)

opts.each do |name, val|
  case name
  when '--help'
    help
    exit
  when '--test'
    set_env_to_test
  when '--development'
    $rails_env = 'development'
  when '--production'
    $rails_env = 'production'
  when '--branch'
    $deploy_branch = val
  end
end

ENV['RAILS_ENV'] = $rails_env

if ARGV.empty?
  help
  exit
end

rest = ARGV[1..].join(' ')

case ARGV.first
when 'help'
  help
when 'setup-folders'
  setup_folders
when 'docker', 'docker_compose', 'docker-compose'
  exec "docker-compose #{rest}"
when 'up'
  exec "docker-compose --profile development up -d"
when 'down'
  exec "docker-compose down"
when 'delete'
  exit 1 if production_environment?

  if yes_or_no?("This is will delete the postgres database.")
    exec "docker-compose down -v"
  end
when 'build'
  exec "docker build -t littlesis:latest ."
when 'pumactl'
  app_exec_bin "pumactl -p tmp/puma.pid #{rest}", use_exec: true, compose_command: "exec"
when 'test', 'rspec'
  set_env_to_test
  app_exec_bin "rspec #{rest}", use_exec: true
when 'rails'
  app_exec_bin "rails #{rest}", use_exec: true
when 'bundle'
  app_exec_bin "bundle #{rest}", use_exec: true
when 'gem'
  gem_path = production_environment? ? '/home/littlesis/.rbenv/shims/gem' : '/usr/local/bin/gem'
  app_exec "#{gem_path} #{rest}", use_exec: true
when 'npm'
  app_exec "npm #{rest}", use_exec: true
when 'rake'
  app_exec_bin! "rake #{rest}"
when 'runner'
  app_exec_bin! "rails runner #{rest}"
when 'script'
  app_exec_bin! "bundle exec lib/scripts/#{rest}"
when 'bash'
  app_exec "/bin/bash --login #{rest}", use_exec: true, compose_command: "exec -i -t"
when 'console', 'c'
  app_exec_bin! "rails c #{rest}"
when 'redis'
  redis_host = production_environment? ? '127.0.0.1' : 'redis'
  app_exec "/usr/bin/redis-cli -h #{redis_host} #{rest}", use_exec: true
when 'data'
  app_exec_bin! "rails runner lib/scripts/data.rb #{rest}"
when 'fec'
  app_exec_bin! "rails runner lib/scripts/fec #{rest}"
when 'git'
  puts git(rest)
when 'rg', 'search'
  exec "rg #{rest}"
when 'find'
  exec "find #{rest}"
when 'edit'
  selected = if rest == ''
               `fd | fzf`.chomp
             else
               rest
             end
  exec "$EDITOR #{selected}"
when 'node'
  app_exec "/usr/bin/node #{rest}", use_exec: true
when 'psql'
  app_exec "psql #{database_connection} #{rest}", use_exec: true, container: 'postgres'
when 'pg_dump', 'pg_restore', 'pg_dumpall', 'pg_basebackup'
  app_exec "#{ARGV.first}  #{rest}", use_exec: true, container: 'postgres', compose_command: 'exec --user postgres'
when 'status'
  status
when 'logs'
  logs
when 'esbuild'
  app_exec "npm run build", use_exec: true
when 'pgenv'
  pgenv
else
  puts "Invalid Command: #{ARGV.first}"
  exit 1
end
