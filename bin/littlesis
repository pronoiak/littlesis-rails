#!/usr/bin/env ruby

require 'getoptlong'
require 'fileutils'

REPO = File.expand_path(File.join(__dir__, '../')).freeze

$database = {
  name: ENV.fetch('LITTLESIS_DATABASE_NAME', 'littlesis'),
  user: ENV.fetch('LITTLESIS_DATABASE_USER', 'littlesis'),
  password: ENV.fetch('LITTLESIS_DATABASE_PASSWORD', 'themanbehindthemanbehindthethrone'),
  host: ENV.fetch('LITTLESIS_DATABASE_HOST', 'postgres')
}

$rails_env = ENV.fetch('RAILS_ENV', 'development')
$deploy_branch = 'main'

def help
  puts <<TEXT
Usage: littlesis [options] <command> [--] [arguments for command]

Commands
           docker           run any docker-compose comand
           up               start docker containers
           down             stop docker containers
           delete           deletes database by removing docker volumes
           build            build littlesis docker image
           bash             interative bash shell
           console          launch rails console
           redis            launch redi cli

LittleSis
          data              ETL utilities for external data
          fec               runs FEC data cli
          deploy            deploys to latest commit on main

Aliases:  bundle, pumactl, rspec, rails, yarn, git rg

TEXT
end

def database_connection
  "postgresql://#{$database[:user]}:#{$database[:password]}@#{$database[:host]}/#{$database[:name]}"
end

def setup_folders
  %w[data data/external_data data/external_data/original data/external_data/csv public/images
     public/images/large public/images/original public/images/profile public/images/small public/images/oligrapher
     public/oligrapher].each do |folder|
    FileUtils.mkdir_p folder
  end
end

def docker_compose(*args)
  Dir.chdir(REPO) do
    exec "docker-compose #{args.join(' ')}"
  end
end

def app_exec(cmd, bin: false)
  raise "not yet implemented" if $rails_env == 'production'
  cmd = "/littlesis/bin/#{cmd}" if bin
  docker_compose 'exec', "-e RAILS_ENV=#{$rails_env}", 'app', cmd
end

def git(cmd)
  Dir.chdir(REPO) { `git #{cmd}` }
end

def status
  current_commit = git("rev-parse --short HEAD").chomp
  current_branch = git("rev-parse --abbrev-ref HEAD").chomp

  puts "On commit #{current_commit} on branch #{current_branch}"

  running_services = Dir.chdir(REPO) { `docker-compose ps --services --filter status=running` }.split("\n")

  %w[redis postgres app nginx].each do |service|
    puts "[#{running_services.include?(service) ? 'âœ“' : 'X'}] #{service} "
  end
end

def deploy
  raise "Cannot deploy unless mode = production" unless $rails_env == 'production'
  Dir.chdir(REPO)

  modified_files = git("ls-files -m").split("\n")

  if modified_files.count.positive?
    puts "The following files have been modified:\n#{modified_files.join("\n")}"
    puts "Are you sure you want to deploy? (y/n)"
    exit 1 unless $stdin.gets.strip.casecmp('y').zero?
  end

  puts "deploying branch #{$deploy_branch}"
  git("fetch origin #{$deploy_branch}")

  remote_commit = git("rev-parse \"origin/#{$deploy_branch}\"").chomp
  local_commit = git("rev-parse @").chomp

  if remote_commit == local_commit
    puts "No upstream changes"
    exit
  end

  git_subject = git("log --format=%s -n 1 \"#{remote_commit}\"")
  puts "Deploying #{remote_commit}: #{git_subject}"
  git("checkout $deploy_branch")
  git("pull")

  changed_files = git("diff --name-only #{remote_commit} #{local_commit}").split("\n")

  if changed_files.any? { |f| f.include?('db/migrate') }
    puts <<-MSG
      +-----------------------------------------------------------+
      These changes likely require a database update,
      which will NOT happen automatically by this script.
      To perform a migration run: "littlesis -P rake db:migrate"
      +-----------------------------------------------------------+
    MSG
  end

  if changed_files.include?('Gemfile') || changed_files.include?('Gemfile.lock')
    `bin/bundle install`
  end

  if changed_files.include?('yarn.lock')
    `bin/yarn`
  end

  # TODO detech changes to Rails.application.config.littlesis.oligrapher_commit and run OligrapherAssetsService.run

  if changed_files.include?('yarn.lock') || changed_files.any? { |f| f.include?('assets') || f.include?('javascript') }
    `bin/rake assets:precompile`
  end

  puts "Restarting LittleSis"
  `bin/pumactl -p tmp/puma.pid restart`
end

opts = GetoptLong.new(
  ['--help', '-h', GetoptLong::NO_ARGUMENT],
  ['--test', '-t', GetoptLong::NO_ARGUMENT],
  ['--development', '-d', GetoptLong::NO_ARGUMENT],
  ['--production', '-P', GetoptLong::NO_ARGUMENT],
  ['--branch', GetoptLong::REQUIRED_ARGUMENT]
)

opts.each do |name, val|
  case name
  when '--help'
    help
    exit
  when '--test'
    $rails_env = 'test'
    $database[:name] = 'littlesis_test'
  when '--development'
    $rails_env = 'development'
  when '--production'
    $rails_env = 'production'
  when '--branch'
    $deploy_branch = val
  end
end

rest = ARGV[1..].join(' ')

case ARGV.first
when 'help'
  help
when 'setup'
  setup_folders
when 'docker', 'docker_compose', 'docker-compose'
  docker_compose rest
when 'up'
  docker_compose 'up -d'
when 'down'
  docker_compose 'down'
when 'delete'
  docker_compose 'down -v'
when 'build'
  Dir.chdir(REPO) { exec "docker build -t littlesis:latest ." }
when 'pumactl'
  app_exec "pumactl -p tmp/puma.pid #{rest}", bin: true
when 'test', 'rspec'
  app_exec "rspec #{rest}", bin: true
when 'rails'
  app_exec "rails #{rest}", bin: true
when 'bundle'
  app_exec "bundle #{rest}", bin: true
when 'yarn'
  app_exec "yarn #{rest}", bin: true
when 'rake'
  app_exec "rake #{rest}", bin: true
when 'runner'
  app_exec "rails runner #{rest}", bin: true
when 'bash'
  app_exec "/bin/bash --login #{rest}"
when 'console', 'c'
  app_exec "rails c #{rest}", bin: true
when 'redis'
  app_exec "/usr/bin/redis-cli -h redis"
when 'data'
  app_exec "rails runner lib/scripts/data.rb #{rest}", bin: true
when 'fec'
  app_exec "rails runner lib/scripts/fec.rb #{rest}", bin: true
when 'git'
  puts git(rest)
when 'rg', 'search'
  Dir.chdir(REPO) { exec "rg #{rest}" }
when 'psql', 'pg_dump', 'pg_restore'
  docker_compose 'run --rm postgres', ARGV.join(' '), database_connection
when 'status'
  status
when 'deploy'
  deploy
end
