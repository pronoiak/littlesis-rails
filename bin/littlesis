#!/usr/bin/env ruby

require 'getoptlong'
require 'fileutils'

# Travel to Rails root relative to this file
REPO = File.expand_path('..', __dir__).freeze
Dir.chdir(REPO)

$database = {
  name: ENV.fetch('LITTLESIS_DATABASE_NAME', 'littlesis'),
  user: ENV.fetch('LITTLESIS_DATABASE_USER', 'littlesis'),
  password: ENV.fetch('LITTLESIS_DATABASE_PASSWORD', 'themanbehindthemanbehindthethrone'),
  host: ENV.fetch('LITTLESIS_DATABASE_HOST', 'postgres')
}

$rails_env = ENV.fetch('RAILS_ENV', 'development')
$deploy_branch = 'main'

def help
  puts <<TEXT
Usage: littlesis [-tdP] <command> [--] [arguments for command]

Commands
           docker           run any docker-compose comand
           up               start docker containers
           down             stop docker containers
           delete           deletes database by removing docker volumes
           build            build littlesis docker image
           bash             interative bash shell
           logs             follow rails logs
           status           check status of applications
           console          launch rails console
           redis            launch redi cli
           data             external data ETL tools
           fec              FEC data ETL tools
           deploy           deploys to latest commit on main
           edit             select file to open with $EDITDOR
           runner           run bin/rails runner <file>
           script           execute named script in lib/scripts/
           esbuild          bundle javascript
           pgenv            use: fish> eval (pgenv)

Aliases
           bundle
           gem
           pumactl
           rspec
           rails
           psql
           pg_dump
           pg_restore
           node
           npm
           git
           rg
           find

TEXT
end

def set_env_to_test
  $rails_env = 'test'
  $database[:name] = 'littlesis_test'
  ENV['RAILS_ENV'] = $rails_env
end

def production_environment?
  $rails_env == 'production'
end

def database_connection
  "postgresql://#{$database[:user]}:#{$database[:password]}@#{$database[:host]}/#{$database[:name]}"
end

def setup_folders
  %w[tmp data data/external_data data/external_data/original data/external_data/csv public/oligrapher public/images
     public/images/large public/images/original public/images/profile public/images/small public/images/oligrapher].each do |folder|
    FileUtils.mkdir_p File.join(REPO, folder)
  end
end

def app_exec(cmd, bin: false, use_exec: false, container: 'app', compose_command: 'run --rm')
  bin_path = $rails_env == 'production' ? '/var/www/littlesis/bin' : '/littlesis/bin'
  cmd = "#{bin_path}/#{cmd}" if bin

  if $rails_env == 'production'
    if use_exec
      exec cmd
    else
      `#{cmd}`
    end
  else
    docker_compose = "docker-compose #{compose_command} -e RAILS_ENV=#{$rails_env} #{container} #{cmd}"

    if use_exec
      exec docker_compose
    else
      `#{docker_compose}`
    end
  end
end

def app_exec_bin(cmd, **kwargs)
  app_exec(cmd, bin: true, **kwargs)
end

def app_exec_bin!(cmd, **kwargs)
  app_exec(cmd, bin: true, use_exec: true, **kwargs)
end

def git(cmd)
  Dir.chdir(REPO) { `git #{cmd}` }
end

def systemd_service_check(service)
  status = system("systemctl is-active -q #{service}") ? '✓' : 'X'
  puts "[#{status}] #{service}"
end

def status
  current_commit = git("rev-parse --short HEAD").chomp
  current_branch = git("rev-parse --abbrev-ref HEAD").chomp

  puts "commit #{current_commit} on branch #{current_branch}"
  puts "Rails Environment \033[1m#{$rails_env}\033[0m"

  if production_environment?
    systemd_service_check 'littlesis'
    systemd_service_check 'littlesis-goodjob'
    systemd_service_check 'redis'
    systemd_service_check 'nginx'
    app_exec_bin 'rake ts:status'
  else
    running_services = `docker-compose ps --services --filter status=running`.split("\n")

    %w[app postgres redis nginx esbuild title_extractor].each do |service|
      puts "[#{running_services.include?(service) ? '✓' : 'X'}] #{service} "
    end
    puts app_exec("rake ts:status", bin: true,  compose_command: "exec")
  end
end

def yes_or_no?(msg)
  printf "#{msg}\n\e[31mpress 'y' to continue: \e[0m"
  $stdin.gets.strip.casecmp('y').zero?
end

def deploy
  raise "Cannot deploy unless mode = production" unless production_environment?

  Dir.chdir(REPO)

  modified_files = git("ls-files -m").split("\n")

  if modified_files.count.positive?
    puts "The following files have been modified:\n#{modified_files.join("\n")}\n"
    exit 1 unless yes_or_no?("Are you sure you want to deploy?")
  end

  puts "deploying branch #{$deploy_branch}"
  git("fetch origin #{$deploy_branch}")

  remote_commit = git("rev-parse \"origin/#{$deploy_branch}\"").chomp
  local_commit = git("rev-parse @").chomp

  if remote_commit == local_commit
    puts "No upstream changes"
    exit
  end

  git_subject = git("log --format=%s -n 1 \"#{remote_commit}\"")
  puts "Deploying #{remote_commit}: #{git_subject}"
  git("checkout $deploy_branch")
  git("pull")

  changed_files = git("diff --name-only #{remote_commit} #{local_commit}").split("\n")

  if changed_files.include?('Gemfile') || changed_files.include?('Gemfile.lock')
    app_exec_bin 'bundle install'
  end

  if changed_files.any? { |f| f.include?('db/migrate') }
    puts "These changes likely require a database update."
    if yes_or_no?("Would you like to run rake db:migrate now?")
      puts app_exec_bin('rake db:migrate')
    end
  end

  if changed_files.include?('package-lock.json')
    puts app_exec('npm ci')
  end

  if changed_files.include?('package-lock.json') || changed_files.any? { |f| f.include?('javascript') }
    puts app_exec('npm run build')
  end

  # TODO detech changes to Rails.application.config.littlesis.oligrapher_commit and run OligrapherAssetsService.run
  if changed_files.any? { |f| f.include?('package-lock.json') || f.include?('assets') || f.include?('javascript') }
    puts app_exec_bin('rake assets:precompile')
  end

  puts "Restarting LittleSis"
  puts app_exec_bin('pumactl -p tmp/puma.pid restart')
end

def logs
  prefix = if production_environment?
             "/var/www/littlesis"
           else
             "/littlesis"
           end

  logfile = "#{prefix}/log/#{$rails_env}.log"

  app_exec "/usr/bin/tail -f #{logfile}", use_exec: true
end

def pgenv
  puts <<~TEXT
    set -x PGHOST  #{$database[:host]};
    set -x PGUSER #{$database[:user]};
    set -x PGPASSWORD #{$database[:password]};
    set -x PGDATABASE #{$database[:name]};
  TEXT
end

# Start processing options

opts = GetoptLong.new(
  ['--help', '-h', GetoptLong::NO_ARGUMENT],
  ['--test', '-t', GetoptLong::NO_ARGUMENT],
  ['--development', '-d', GetoptLong::NO_ARGUMENT],
  ['--production', '-P', GetoptLong::NO_ARGUMENT],
  ['--branch', GetoptLong::REQUIRED_ARGUMENT]
)

opts.each do |name, val|
  case name
  when '--help'
    help
    exit
  when '--test'
    set_env_to_test
  when '--development'
    $rails_env = 'development'
  when '--production'
    $rails_env = 'production'
  when '--branch'
    $deploy_branch = val
  end
end

ENV['RAILS_ENV'] = $rails_env

if ARGV.empty?
  help
  exit
end

rest = ARGV[1..].join(' ')

case ARGV.first
when 'help'
  help
when 'setup-folders'
  setup_folders
when 'docker', 'docker_compose', 'docker-compose'
  exec "docker-compose #{rest}"
when 'up'
  exec "docker-compose --profile development up -d"
when 'down'
  exec "docker-compose down"
when 'delete'
  exit 1 if production_environment?

  if yes_or_no?("This is will delete the postgres database.")
    exec "docker-compose down -v"
  end
when 'build'
  exec "docker build -t littlesis:latest ."
when 'pumactl'
  app_exec_bin "pumactl -p tmp/puma.pid #{rest}", use_exec: true, compose_command: "exec"
when 'test', 'rspec'
  set_env_to_test
  app_exec_bin "rspec #{rest}", use_exec: true
when 'rails'
  app_exec_bin "rails #{rest}", use_exec: true
when 'bundle'
  app_exec_bin "bundle #{rest}", use_exec: true
when 'gem'
  gem_path = production_environment? ? '/home/littlesis/.rbenv/shims/gem' : '/usr/local/bin/gem'
  app_exec "#{gem_path} #{rest}", use_exec: true
when 'npm'
  app_exec "npm #{rest}", use_exec: true
when 'rake'
  app_exec_bin! "rake #{rest}"
when 'runner'
  app_exec_bin! "rails runner #{rest}"
when 'script'
  app_exec_bin! "bundle exec lib/scripts/#{rest}"
when 'bash'
  app_exec "/bin/bash --login #{rest}", use_exec: true, compose_command: "exec -i -t"
when 'console', 'c'
  app_exec_bin! "rails c #{rest}"
when 'redis'
  redis_host = production_environment? ? '127.0.0.1' : 'redis'
  app_exec "/usr/bin/redis-cli -h #{redis_host} #{rest}", use_exec: true
when 'data'
  app_exec_bin! "rails runner lib/scripts/data.rb #{rest}"
when 'fec'
  app_exec_bin! "rails runner lib/scripts/fec #{rest}"
when 'git'
  puts git(rest)
when 'rg', 'search'
  exec "rg #{rest}"
when 'find'
  exec "find #{rest}"
when 'edit'
  selected = if rest == ''
               `fd | fzf`.chomp
             else
               rest
             end
  exec "$EDITOR #{selected}"
when 'node'
  app_exec "/usr/bin/node #{rest}", use_exec: true
when 'psql'
  app_exec "psql #{database_connection} #{rest}", use_exec: true, container: 'postgres'
when 'pg_dump', 'pg_restore', 'pg_dumpall', 'pg_basebackup'
  app_exec "#{ARGV.first}  #{rest}", use_exec: true, container: 'postgres', compose_command: 'exec --user postgres'
when 'status'
  status
when 'deploy'
  deploy
when 'logs'
  logs
when 'esbuild'
  app_exec "npm run build", use_exec: true
when 'pgenv'
  pgenv
else
  puts "Invalid Command: #{ARGV.first}"
  exit 1
end
